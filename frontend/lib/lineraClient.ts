export interface PlayerEndpoint {
  chainId: string;
  owner: string;
  url: string;
}

export interface LineraConfig {
  applicationId: string;
  playChain: string;
  endpoints: PlayerEndpoint[];
  playerNumber?: number;
}

export class LineraClient {
  private config: LineraConfig;
  private playerNumber: number;

  constructor(config: LineraConfig) {
    this.config = config;
    this.playerNumber = 1; // Default to 1, effectively ignored as we use endpoint[0]
  }

  private getEndpoint(): PlayerEndpoint {
    // simplified: always use the first (and only) endpoint in the list
    const endpoint = this.config.endpoints[0];
    if (!endpoint) {
      throw new Error(`No endpoint configured in config.json`);
    }
    return endpoint;
  }

  async query<T>(query: string, variables?: Record<string, any>, chainId?: string): Promise<T> {
    const endpoint = this.getEndpoint();
    const targetChainId = chainId || endpoint.chainId;
    const url = `${endpoint.url}/chains/${targetChainId}/applications/${this.config.applicationId}`;

    const response = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ query, variables }),
    });

    if (!response.ok) {
      throw new Error(`GraphQL request failed: ${response.statusText}`);
    }

    const result = await response.json();

    if (result.errors) {
      throw new Error(`GraphQL errors: ${JSON.stringify(result.errors)}`);
    }

    return result.data as T;
  }

  async mutate<T>(
    mutation: string,
    variables?: Record<string, any>,
    chainId?: string
  ): Promise<T> {
    return this.query<T>(mutation, variables, chainId);
  }

  getOwner(): string {
    return this.getEndpoint().owner;
  }

  getChainId(): string {
    return this.getEndpoint().chainId;
  }
}

let globalConfig: LineraConfig | null = null;

export function setGlobalConfig(config: LineraConfig): void {
  globalConfig = config;
}

export function getGlobalConfig(): LineraConfig {
  if (!globalConfig) {
    throw new Error(
      "Linera config not initialized. Call loadConfig first."
    );
  }
  return globalConfig;
}

export function createLineraClient(playerNumber?: number): LineraClient {
  const config = getGlobalConfig();
  return new LineraClient(config);
}

/**
 * Hybrid config loader (Option C): Try runtime config.json first, fallback to env vars
 */
export async function loadConfig(): Promise<LineraConfig> {
  // Try loading runtime config.json (generated by deployment script)
  try {
    const response = await fetch("/config.json");
    if (response.ok) {
      const config = await response.json();
      
      // Check if it's the new multiplayer format
      if (config.endpoints && Array.isArray(config.endpoints)) {
        setGlobalConfig(config);
        return config;
      }
      
      // Handle legacy single-player format
      const legacyConfig: LineraConfig = {
        applicationId: config.appId || config.applicationId,
        playChain: config.chainId,
        endpoints: [
          {
            chainId: config.userChain || config.chainId,
            owner: "",
            url: config.nodeServiceURL || config.endpoint,
          },
        ],
      };
      setGlobalConfig(legacyConfig);
      return legacyConfig;
    }
  } catch (error) {
    console.log("No runtime config.json found, using environment variables");
  }

  // Fallback to environment variables (single player mode)
  const fallbackConfig: LineraConfig = {
    applicationId: process.env.NEXT_PUBLIC_APP_ID || "",
    playChain: process.env.NEXT_PUBLIC_CHAIN_ID || "",
    endpoints: [
      {
        chainId: process.env.NEXT_PUBLIC_CHAIN_ID || "",
        owner: "",
        url: process.env.NEXT_PUBLIC_LINERA_ENDPOINT || "http://localhost:8081",
      },
    ],
  };
  setGlobalConfig(fallbackConfig);
  return fallbackConfig;
}
